<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tanzimat Reforms Monopoly</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a237e 0%, #283593 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 3px solid #3949ab;
            padding-bottom: 20px;
        }

        h1 {
            color: #1a237e;
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .subtitle {
            color: #5c6bc0;
            font-size: 1.2rem;
            font-style: italic;
        }

        /* Player Setup Modal */
        .player-setup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .setup-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .setup-content h2 {
            color: #1a237e;
            margin-bottom: 20px;
            text-align: center;
        }

        .player-input-group {
            margin-bottom: 20px;
        }

        .player-input-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
        }

        .player-input-group input,
        .player-input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #c5cae9;
            border-radius: 8px;
            font-size: 1rem;
        }

        .player-input-group input:focus,
        .player-input-group select:focus {
            outline: none;
            border-color: #3949ab;
        }

        .player-color-preview {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 10px;
            border: 2px solid #333;
        }

        /* Game Layout */
        .game-layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 1100px) {
            .game-layout {
                grid-template-columns: 1fr;
            }
        }

        /* Monopoly Board Container */
        .board-container {
            position: relative;
            background: #f5f5f5;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            min-height: 700px;
        }

        .board-title {
            text-align: center;
            color: #1a237e;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        /* Classic Monopoly Board Layout - FIXED DIMENSIONS */
        .monopoly-board {
            width: 600px; /* SMALLER for better fit */
            height: 600px; /* SMALLER for better fit */
            margin: 0 auto;
            position: relative;
            background: #bbdefb;
            border-radius: 10px;
            border: 3px solid #1a237e;
        }

        /* Board Cells - Fixed dimensions */
        .board-cell {
            position: absolute;
            background: white;
            border: 1px solid #90a4ae;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 3px;
            transition: all 0.3s ease;
            overflow: hidden;
            font-size: 0.6rem;
            line-height: 1.1;
        }

        .board-cell:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        .board-cell.active {
            border: 2px solid #ff9800;
            background: #fff3e0;
        }

        .cell-number {
            position: absolute;
            top: 1px;
            left: 1px;
            font-size: 0.6rem;
            color: #666;
            font-weight: bold;
            background: rgba(255,255,255,0.8);
            border-radius: 50%;
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cell-title {
            font-size: 0.6rem;
            font-weight: bold;
            margin-bottom: 1px;
            color: #1a237e;
        }

        .cell-description {
            font-size: 0.5rem;
            opacity: 0.8;
        }

        /* Corner cells */
        .corner-cell {
            width: 80px; /* SMALLER */
            height: 80px; /* SMALLER */
            background: linear-gradient(135deg, #3949ab 0%, #283593 100%);
            color: white;
            font-weight: bold;
            border: 2px solid #1a237e;
            z-index: 5;
        }

        .corner-cell .cell-title {
            color: white;
            font-size: 0.8rem;
        }

        /* Property cells */
        .property-cell {
            width: 60px; /* SMALLER */
            height: 75px; /* SMALLER */
        }

        /* Horizontal properties */
        .horizontal-cell {
            width: 73.75px; /* (600 - 160) / 8 = 55, wait let me recalculate */
            height: 60px; /* SMALLER */
        }

        /* Center area */
        .board-center {
            position: absolute;
            top: 80px; /* Match corner height */
            left: 80px; /* Match corner width */
            width: 440px; /* 600 - 2*80 = 440 */
            height: 440px; /* 600 - 2*80 = 440 */
            background: #e3f2fd;
            border: 2px dashed #1a237e;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 15px;
            z-index: 1;
        }

        .center-title {
            font-size: 1.3rem;
            color: #1a237e;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }

        .center-subtitle {
            font-size: 0.9rem;
            color: #5c6bc0;
            text-align: center;
            max-width: 80%;
        }

        /* Player tokens */
        .player-token {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            position: absolute;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 20;
        }

        /* Color coding for properties */
        .property-did-you-know {
            border-top: 4px solid #4caf50;
        }

        .property-true-false {
            border-top: 4px solid #ff9800;
        }

        .property-what-next {
            border-top: 4px solid #2196f3;
        }

        .property-two-truths {
            border-top: 4px solid #9c27b0;
        }

        /* Special cells */
        .chance-cell {
            background: #fff3e0;
            border-top: 4px solid #ff9800;
        }

        .community-chest-cell {
            background: #f3e5f5;
            border-top: 4px solid #9c27b0;
        }

        .railroad-cell {
            background: #e0f2f1;
            border-top: 4px solid #00695c;
        }

        .utility-cell {
            background: #fce4ec;
            border-top: 4px solid #c2185b;
        }

        .tax-cell {
            background: #ffebee;
            border-top: 4px solid #f44336;
        }

        /* Dice Area */
        .dice-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
            padding: 20px;
            background: #e8eaf6;
            border-radius: 15px;
        }

        .dice-container {
            display: flex;
            gap: 20px;
        }

        .dice {
            width: 60px;
            height: 60px;
            background: white;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            font-weight: bold;
            color: #1a237e;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.5s ease;
            cursor: pointer;
        }

        .dice.rolling {
            animation: rollDice 0.5s ease-in-out infinite;
        }

        @keyframes rollDice {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        /* Players Panel */
        .players-panel {
            background: #e8eaf6;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
        }

        .player-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #3949ab;
            transition: all 0.3s ease;
        }

        .player-card.active {
            border-left: 4px solid #4caf50;
            background: #f1f8e9;
            transform: translateX(5px);
        }

        .player-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .player-color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .player-name {
            font-weight: bold;
            color: #1a237e;
            font-size: 1.1rem;
        }

        .player-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.9rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }

        .stat-value {
            font-weight: bold;
            color: #3949ab;
        }

        /* Card Display */
        .card-display {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }

        .card-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px 0;
        }

        .card-title {
            font-size: 1.5rem;
            color: #1a237e;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e8eaf6;
            width: 100%;
        }

        .card-text {
            font-size: 1.2rem;
            line-height: 1.6;
            color: #333;
            margin-bottom: 30px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
        }

        .answer-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            margin-top: 20px;
        }

        .answer-btn {
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: #e8eaf6;
            color: #3949ab;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .answer-btn:hover:not(:disabled) {
            background: #3949ab;
            color: white;
            transform: translateY(-2px);
        }

        .answer-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 160px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3949ab 0%, #283593 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(57, 73, 171, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #e8eaf6;
            color: #3949ab;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #c5cae9;
            transform: translateY(-3px);
        }

        .btn-secondary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .fact-result {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            font-weight: bold;
            text-align: center;
            display: none;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .correct {
            background: #e8f5e9;
            color: #2e7d32;
            border: 2px solid #4caf50;
        }

        .incorrect {
            background: #ffebee;
            color: #c62828;
            border: 2px solid #f44336;
        }

        .game-log {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-title {
            font-weight: bold;
            color: #1a237e;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .log-entry {
            padding: 8px;
            border-bottom: 1px solid #ddd;
            font-size: 0.9rem;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .category-key {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .key-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .key-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .winner-banner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #4caf50, #2e7d32);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 1001;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: none;
            animation: popIn 0.5s ease;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .winner-banner h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
        }

        .winner-banner p {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        .space-answered {
            background: #e0e0e0 !important;
            border-color: #9e9e9e !important;
        }

        .property-owned {
            position: relative;
        }

        .property-owned::after {
            content: '';
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <!-- Player Setup Modal -->
    <div class="player-setup" id="playerSetup">
        <div class="setup-content">
            <h2>üé≠ Setup Your Tanzimat Reforms Monopoly</h2>
            <div class="player-input-group">
                <label for="playerCount">Number of Reformers (2-4)</label>
                <select id="playerCount">
                    <option value="2">2 Reformers</option>
                    <option value="3" selected>3 Reformers</option>
                    <option value="4">4 Reformers</option>
                </select>
            </div>
            <div id="playerForms">
                <!-- Player forms will be generated here -->
            </div>
            <button class="btn btn-primary" id="startGameBtn" style="width: 100%; margin-top: 20px;">Start Reform Game</button>
        </div>
    </div>

    <!-- Winner Banner -->
    <div class="winner-banner" id="winnerBanner">
        <h2>üéâ Reform Success! üéâ</h2>
        <p id="winnerMessage"></p>
        <button class="btn btn-primary" onclick="resetGame()">Play Again</button>
    </div>

    <div class="container" id="gameContainer" style="display: none;">
        <header>
            <h1>üèõÔ∏è Tanzimat Reforms Monopoly</h1>
            <p class="subtitle">Buy properties, answer questions, and lead the Ottoman Empire to modernization!</p>
        </header>

        <div class="game-layout">
            <div class="board-container">
                <h3 class="board-title">The Tanzimat Reform Board</h3>
                <div class="monopoly-board" id="gameBoard">
                    <!-- Center area -->
                    <div class="board-center">
                        <div class="center-title">TANZƒ∞MAT REFORMS</div>
                        <div class="center-subtitle">1839-1876</div>
                        <div style="margin-top: 20px; font-size: 0.8rem; color: #666;">
                            <p>Roll dice to move around the board</p>
                            <p>Answer questions to earn Knowledge Points</p>
                            <p>Buy properties to establish reform influence</p>
                        </div>
                    </div>
                    <!-- Board cells will be generated by JavaScript -->
                </div>
                
                <div class="dice-area">
                    <h3>Current Reformer: <span id="currentPlayerName">-</span></h3>
                    <div class="dice-container">
                        <div class="dice" id="dice1">‚öÄ</div>
                        <div class="dice" id="dice2">‚öÄ</div>
                    </div>
                    <div class="controls">
                        <button class="btn btn-primary" id="rollDiceBtn" disabled>üé≤ Roll Dice</button>
                        <button class="btn btn-secondary" id="nextTurnBtn" style="display: none;" disabled>End Turn</button>
                    </div>
                    <div id="diceResult" style="font-size: 1.2rem; font-weight: bold; color: #1a237e;"></div>
                </div>
            </div>

            <div class="right-panel">
                <div class="players-panel" id="playersPanel">
                    <!-- Player cards will be generated here -->
                </div>

                <div class="card-display">
                    <div class="card-title" id="currentCategory">Welcome to Tanzimat Reforms!</div>
                    <div class="card-content">
                        <div class="card-text" id="cardText">
                            Click "Roll Dice" to begin your journey around the Reform Board. 
                            Buy properties, answer questions, and become the greatest reformer!
                        </div>
                        
                        <div class="answer-options" id="answerOptions" style="display: none;">
                            <!-- Answer buttons will be generated here -->
                        </div>
                        
                        <div class="fact-result" id="factResult">
                            <!-- Result message appears here -->
                        </div>
                    </div>
                </div>

                <div class="game-log">
                    <div class="log-title">Reform Chronicle:</div>
                    <div id="logEntries">
                        <div class="log-entry">Welcome to the Tanzimat Reforms Monopoly game!</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="category-key">
            <div class="key-item">
                <div class="key-color" style="background: #4caf50;"></div>
                <span>Did You Know? Properties</span>
            </div>
            <div class="key-item">
                <div class="key-color" style="background: #ff9800;"></div>
                <span>True/False? Properties</span>
            </div>
            <div class="key-item">
                <div class="key-color" style="background: #2196f3;"></div>
                <span>What Happened Next? Properties</span>
            </div>
            <div class="key-item">
                <div class="key-color" style="background: #9c27b0;"></div>
                <span>Two Truths & a Lie Properties</span>
            </div>
        </div>
    </div>

    <script>
        // Game Configuration
        const PLAYER_COLORS = ['#FF5252', '#4CAF50', '#2196F3', '#FF9800'];
        const PLAYER_NAMES = ['Mustafa Re≈üid Pasha', 'Sultan Abd√ºlmecid I', 'Sultan Mahmud II', 'Young Ottoman'];
        const STARTING_KNOWLEDGE = 150;
        const STARTING_MONEY = 1500;
        
        // Board dimensions - SMALLER for perfect fit
        const BOARD_WIDTH = 600;
        const BOARD_HEIGHT = 600;
        const CORNER_SIZE = 80; // Smaller corners
        const PROPERTY_WIDTH = 60; // Smaller vertical properties
        const PROPERTY_HEIGHT = 75; // Smaller vertical properties
        const HORIZONTAL_CELLS_PER_SIDE = 9; // 9 cells per side (excluding corners)
        const HORIZONTAL_WIDTH = (BOARD_WIDTH - (2 * CORNER_SIZE)) / HORIZONTAL_CELLS_PER_SIDE; // Calculate dynamically
        const HORIZONTAL_HEIGHT = 60; // Smaller horizontal properties
        
        console.log("Horizontal width calculation:", HORIZONTAL_WIDTH); // Should be 48.888...

        // Monopoly Board Configuration (40 spaces)
        const BOARD_SPACES = [
            // Corner spaces (positions 0, 10, 20, 30)
            { 
                position: 0, type: 'corner', name: 'GO', 
                description: 'Collect 200 KP', 
                action: 'collect', amount: 200 
            },
            { 
                position: 10, type: 'corner', name: 'JAIL', 
                description: 'Janissary Crisis', 
                action: 'jail' 
            },
            { 
                position: 20, type: 'corner', name: 'FREE PARK', 
                description: 'Reform Rest', 
                action: 'free' 
            },
            { 
                position: 30, type: 'corner', name: 'GO TO JAIL', 
                description: 'Go to Janissary Crisis', 
                action: 'gotojail' 
            },
            
            // Bottom row (positions 1-9) - Horizontal, right to left
            { 
                position: 1, type: 'property', name: 'Rose Garden', 
                category: 'did-you-know', price: 60, rent: 2,
                group: 'did-you-know', color: '#4caf50'
            },
            { 
                position: 2, type: 'community-chest', name: 'Reform Card', 
                description: 'Draw a card', 
                action: 'community-chest' 
            },
            { 
                position: 3, type: 'property', name: 'Military', 
                category: 'did-you-know', price: 60, rent: 4,
                group: 'did-you-know', color: '#4caf50'
            },
            { 
                position: 4, type: 'tax', name: 'Reform Tax', 
                description: 'Pay 200 KP', 
                action: 'pay', amount: 200 
            },
            { 
                position: 5, type: 'railroad', name: 'Telegraph', 
                description: 'Rent: 25', 
                action: 'railroad', price: 200, rent: 25 
            },
            { 
                position: 6, type: 'property', name: 'Legal Code', 
                category: 'true-false', price: 100, rent: 6,
                group: 'true-false', color: '#ff9800'
            },
            { 
                position: 7, type: 'chance', name: 'Chance', 
                description: 'Draw a card', 
                action: 'chance' 
            },
            { 
                position: 8, type: 'property', name: 'Education', 
                category: 'true-false', price: 100, rent: 6,
                group: 'true-false', color: '#ff9800'
            },
            { 
                position: 9, type: 'property', name: 'Tax Reform', 
                category: 'true-false', price: 120, rent: 8,
                group: 'true-false', color: '#ff9800'
            },
            
            // Left side (positions 11-19) - Vertical, bottom to top
            { 
                position: 11, type: 'property', name: 'Secular Schools', 
                category: 'what-next', price: 140, rent: 10,
                group: 'what-next', color: '#2196f3'
            },
            { 
                position: 12, type: 'utility', name: 'Newspapers', 
                description: 'Utility', 
                action: 'utility', price: 150 
            },
            { 
                position: 13, type: 'property', name: 'Postal Service', 
                category: 'what-next', price: 140, rent: 10,
                group: 'what-next', color: '#2196f3'
            },
            { 
                position: 14, type: 'property', name: 'Telegraph Lines', 
                category: 'what-next', price: 160, rent: 12,
                group: 'what-next', color: '#2196f3'
            },
            { 
                position: 15, type: 'railroad', name: 'Railway', 
                description: 'Rent: 25', 
                action: 'railroad', price: 200, rent: 25 
            },
            { 
                position: 16, type: 'property', name: 'Banking', 
                category: 'two-truths', price: 180, rent: 14,
                group: 'two-truths', color: '#9c27b0'
            },
            { 
                position: 17, type: 'community-chest', name: 'Reform Card', 
                description: 'Draw a card', 
                action: 'community-chest' 
            },
            { 
                position: 18, type: 'property', name: 'Industrial', 
                category: 'two-truths', price: 180, rent: 14,
                group: 'two-truths', color: '#9c27b0'
            },
            { 
                position: 19, type: 'property', name: 'Factories', 
                category: 'two-truths', price: 200, rent: 16,
                group: 'two-truths', color: '#9c27b0'
            },
            
            // Top row (positions 21-29) - Horizontal, left to right
            { 
                position: 21, type: 'property', name: 'New Courts', 
                category: 'did-you-know', price: 220, rent: 18,
                group: 'did-you-know', color: '#4caf50'
            },
            { 
                position: 22, type: 'chance', name: 'Chance', 
                description: 'Draw a card', 
                action: 'chance' 
            },
            { 
                position: 23, type: 'property', name: 'Land Code', 
                category: 'did-you-know', price: 220, rent: 18,
                group: 'did-you-know', color: '#4caf50'
            },
            { 
                position: 24, type: 'property', name: 'Conscription', 
                category: 'did-you-know', price: 240, rent: 20,
                group: 'did-you-know', color: '#4caf50'
            },
            { 
                position: 25, type: 'railroad', name: 'Steamships', 
                description: 'Rent: 25', 
                action: 'railroad', price: 200, rent: 25 
            },
            { 
                position: 26, type: 'property', name: 'Foreign Policy', 
                category: 'true-false', price: 260, rent: 22,
                group: 'true-false', color: '#ff9800'
            },
            { 
                position: 27, type: 'property', name: 'Western Ed', 
                category: 'true-false', price: 260, rent: 22,
                group: 'true-false', color: '#ff9800'
            },
            { 
                position: 28, type: 'utility', name: 'Post Office', 
                description: 'Utility', 
                action: 'utility', price: 150 
            },
            { 
                position: 29, type: 'property', name: 'Bureaucracy', 
                category: 'true-false', price: 280, rent: 24,
                group: 'true-false', color: '#ff9800'
            },
            
            // Right side (positions 31-39) - Vertical, top to bottom
            { 
                position: 31, type: 'property', name: 'Constitution', 
                category: 'what-next', price: 300, rent: 26,
                group: 'what-next', color: '#2196f3'
            },
            { 
                position: 32, type: 'property', name: 'Parliament', 
                category: 'what-next', price: 300, rent: 26,
                group: 'what-next', color: '#2196f3'
            },
            { 
                position: 33, type: 'community-chest', name: 'Reform Card', 
                description: 'Draw a card', 
                action: 'community-chest' 
            },
            { 
                position: 34, type: 'property', name: 'Press Freedom', 
                category: 'what-next', price: 320, rent: 28,
                group: 'what-next', color: '#2196f3'
            },
            { 
                position: 35, type: 'railroad', name: 'Road Network', 
                description: 'Rent: 25', 
                action: 'railroad', price: 200, rent: 25 
            },
            { 
                position: 36, type: 'chance', name: 'Chance', 
                description: 'Draw a card', 
                action: 'chance' 
            },
            { 
                position: 37, type: 'property', name: 'Modern Army', 
                category: 'two-truths', price: 350, rent: 35,
                group: 'two-truths', color: '#9c27b0'
            },
            { 
                position: 38, type: 'tax', name: 'Luxury Tax', 
                description: 'Pay 100 KP', 
                action: 'pay', amount: 100 
            },
            { 
                position: 39, type: 'property', name: 'Final Reforms', 
                category: 'two-truths', price: 400, rent: 50,
                group: 'two-truths', color: '#9c27b0'
            }
        ];

        // Community Chest Cards
        const COMMUNITY_CHEST_CARDS = [
            { text: "Your reform proposals are accepted! Advance to GO.", action: "move", target: 0, collect: 200 },
            { text: "Bank error in your favor. Collect 100 Knowledge Points.", action: "collect", amount: 100 },
            { text: "Pay school fees. Lose 50 Knowledge Points.", action: "pay", amount: 50 },
            { text: "You have won a reform competition. Collect 150 Knowledge Points.", action: "collect", amount: 150 }
        ];

        // Chance Cards
        const CHANCE_CARDS = [
            { text: "Advance to the Rose Garden Edict.", action: "move", target: 1 },
            { text: "Foreign investors support your reforms. Collect 150 Knowledge Points.", action: "collect", amount: 150 },
            { text: "Go back 3 spaces.", action: "move", amount: -3 },
            { text: "Your reform committee has matured. Collect 100 Knowledge Points.", action: "collect", amount: 100 }
        ];

        // Facts database
        const facts = {
            'did-you-know': [
                {
                    text: "The G√ºlhane Hatt-ƒ± ≈ûerif (Rose Garden Edict) of 1839 was read in an open park to symbolize its public nature.",
                    points: 25
                }
            ],
            'true-false': [
                {
                    text: "The Tanzimat reforms successfully eliminated all religious discrimination in the Ottoman Empire.",
                    answer: false,
                    explanation: "FALSE. While laws proclaimed equality, social practice maintained significant Muslim privilege.",
                    points: 40
                }
            ],
            'what-next': [
                {
                    setup: "After the 1839 Rose Garden Edict promised equality and modern administration...",
                    options: [
                        "European powers immediately recognized Ottoman sovereignty.",
                        "New secular courts and modern schools were established despite resistance.",
                        "The Empire collapsed within five years."
                    ],
                    correct: 1,
                    explanation: "New institutions were created, but implementation faced resistance.",
                    points: 50
                }
            ],
            'two-truths': [
                {
                    statements: [
                        "Sultan Mahmud II centralized power by crushing the Janissaries.",
                        "Reformers planned gradual change over a century.",
                        "European-style uniforms were adopted to project modern authority."
                    ],
                    lieIndex: 1,
                    explanation: "The lie is #2. Reformers wanted RAPID transformation.",
                    points: 60
                }
            ]
        };

        // Game State
        const gameState = {
            players: [],
            currentPlayerIndex: 0,
            gameActive: false,
            currentCard: null,
            currentSpace: null,
            diceRolled: false,
            questionAnswered: false,
            properties: BOARD_SPACES.filter(space => space.type === 'property').map(prop => ({
                ...prop,
                owner: null,
                mortgaged: false
            })),
            communityChestDeck: [...COMMUNITY_CHEST_CARDS],
            chanceDeck: [...CHANCE_CARDS]
        };

        // DOM Elements
        const playerSetup = document.getElementById('playerSetup');
        const gameContainer = document.getElementById('gameContainer');
        const playerCountSelect = document.getElementById('playerCount');
        const playerForms = document.getElementById('playerForms');
        const startGameBtn = document.getElementById('startGameBtn');
        const gameBoard = document.getElementById('gameBoard');
        const playersPanel = document.getElementById('playersPanel');
        const dice1 = document.getElementById('dice1');
        const dice2 = document.getElementById('dice2');
        const rollDiceBtn = document.getElementById('rollDiceBtn');
        const nextTurnBtn = document.getElementById('nextTurnBtn');
        const currentPlayerNameEl = document.getElementById('currentPlayerName');
        const currentCategoryEl = document.getElementById('currentCategory');
        const cardTextEl = document.getElementById('cardText');
        const answerOptionsEl = document.getElementById('answerOptions');
        const factResultEl = document.getElementById('factResult');
        const logEntriesEl = document.getElementById('logEntries');
        const diceResultEl = document.getElementById('diceResult');
        const winnerBanner = document.getElementById('winnerBanner');
        const winnerMessage = document.getElementById('winnerMessage');

        // Initialize player forms
        function initializePlayerForms() {
            const count = parseInt(playerCountSelect.value);
            playerForms.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                playerForms.innerHTML += `
                    <div class="player-input-group">
                        <label>Reformer ${i + 1} Name</label>
                        <input type="text" id="playerName${i}" value="${PLAYER_NAMES[i] || `Reformer ${i + 1}`}">
                        <label>Choose Color</label>
                        <select id="playerColor${i}">
                            ${PLAYER_COLORS.map((color, idx) => 
                                `<option value="${color}" ${idx === i ? 'selected' : ''}>Color ${idx + 1}</option>`
                            ).join('')}
                        </select>
                        <div class="player-color-preview" id="colorPreview${i}" style="background: ${PLAYER_COLORS[i]}"></div>
                    </div>
                `;
                
                document.getElementById(`playerColor${i}`).addEventListener('change', (e) => {
                    document.getElementById(`colorPreview${i}`).style.background = e.target.value;
                });
            }
        }

        // Generate the Monopoly board with perfect positioning
        function generateBoard() {
            // Clear existing cells except center
            document.querySelectorAll('.board-cell').forEach(cell => {
                if (!cell.classList.contains('board-center')) {
                    cell.remove();
                }
            });
            
            // Create board cells in Monopoly layout
            BOARD_SPACES.forEach((space) => {
                const cell = document.createElement('div');
                cell.className = `board-cell`;
                cell.dataset.position = space.position;
                cell.id = `cell-${space.position}`;
                
                // Add specific classes based on space type
                if (space.type === 'corner') {
                    cell.classList.add('corner-cell');
                } else if (space.type === 'property') {
                    cell.classList.add('property-cell');
                    cell.classList.add(`property-${space.category.replace('-', '')}`);
                } else if (space.type === 'chance') {
                    cell.classList.add('horizontal-cell', 'chance-cell');
                } else if (space.type === 'community-chest') {
                    cell.classList.add('horizontal-cell', 'community-chest-cell');
                } else if (space.type === 'railroad') {
                    cell.classList.add('horizontal-cell', 'railroad-cell');
                } else if (space.type === 'utility') {
                    cell.classList.add('horizontal-cell', 'utility-cell');
                } else if (space.type === 'tax') {
                    cell.classList.add('horizontal-cell', 'tax-cell');
                }
                
                // Add content
                cell.innerHTML = `
                    <div class="cell-number">${space.position}</div>
                    <div class="cell-title">${space.name}</div>
                    ${space.description ? `<div class="cell-description">${space.description}</div>` : ''}
                    ${space.price ? `<div class="cell-description">KP ${space.price}</div>` : ''}
                `;
                
                // Position the cell on the board
                positionCell(cell, space.position);
                
                gameBoard.appendChild(cell);
            });
            
            // Update player tokens
            updatePlayerTokens();
        }

        // Position cells on Monopoly board with EXACT coordinates
        function positionCell(cell, position) {
            const availableWidth = BOARD_WIDTH - (2 * CORNER_SIZE);
            const cellWidth = availableWidth / 9; // 9 cells per side
            
            // Bottom row (positions 1-9) - Horizontal, right to left
            if (position >= 1 && position <= 9) {
                // Position 1 should be just left of GO corner
                // Position 9 should be just right of JAIL corner
                const cellIndex = position - 1; // 0-8
                const x = BOARD_WIDTH - CORNER_SIZE - (cellIndex * cellWidth) - cellWidth;
                cell.style.left = `${x}px`;
                cell.style.bottom = '0px';
                cell.style.width = `${cellWidth}px`;
                cell.style.height = `${HORIZONTAL_HEIGHT}px`;
            }
            // Left side (positions 11-19) - Vertical, bottom to top
            else if (position >= 11 && position <= 19) {
                const cellIndex = position - 11; // 0-8
                const availableHeight = BOARD_HEIGHT - (2 * CORNER_SIZE);
                const cellHeight = availableHeight / 9;
                const y = BOARD_HEIGHT - CORNER_SIZE - (cellIndex * cellHeight) - cellHeight;
                cell.style.left = '0px';
                cell.style.bottom = `${y}px`;
                cell.style.width = `${PROPERTY_WIDTH}px`;
                cell.style.height = `${cellHeight}px`;
            }
            // Top row (positions 21-29) - Horizontal, left to right
            else if (position >= 21 && position <= 29) {
                const cellIndex = position - 21; // 0-8
                const x = CORNER_SIZE + (cellIndex * cellWidth);
                cell.style.left = `${x}px`;
                cell.style.top = '0px';
                cell.style.width = `${cellWidth}px`;
                cell.style.height = `${HORIZONTAL_HEIGHT}px`;
            }
            // Right side (positions 31-39) - Vertical, top to bottom
            else if (position >= 31 && position <= 39) {
                const cellIndex = position - 31; // 0-8
                const availableHeight = BOARD_HEIGHT - (2 * CORNER_SIZE);
                const cellHeight = availableHeight / 9;
                const y = CORNER_SIZE + (cellIndex * cellHeight);
                cell.style.right = '0px';
                cell.style.top = `${y}px`;
                cell.style.width = `${PROPERTY_WIDTH}px`;
                cell.style.height = `${cellHeight}px`;
            }
            // Corner positions
            else if (position === 0) { // GO - Bottom right
                cell.style.right = '0px';
                cell.style.bottom = '0px';
                cell.style.width = `${CORNER_SIZE}px`;
                cell.style.height = `${CORNER_SIZE}px`;
            } else if (position === 10) { // JAIL - Bottom left
                cell.style.left = '0px';
                cell.style.bottom = '0px';
                cell.style.width = `${CORNER_SIZE}px`;
                cell.style.height = `${CORNER_SIZE}px`;
            } else if (position === 20) { // FREE PARK - Top left
                cell.style.left = '0px';
                cell.style.top = '0px';
                cell.style.width = `${CORNER_SIZE}px`;
                cell.style.height = `${CORNER_SIZE}px`;
            } else if (position === 30) { // GO TO JAIL - Top right
                cell.style.right = '0px';
                cell.style.top = '0px';
                cell.style.width = `${CORNER_SIZE}px`;
                cell.style.height = `${CORNER_SIZE}px`;
            }
        }

        // Update player tokens on board
        function updatePlayerTokens() {
            // Clear existing tokens
            document.querySelectorAll('.player-token').forEach(token => token.remove());
            
            // Add tokens for each player
            gameState.players.forEach((player, playerIndex) => {
                const cell = document.getElementById(`cell-${player.position}`);
                if (cell) {
                    const token = document.createElement('div');
                    token.className = 'player-token';
                    token.style.background = player.color;
                    
                    // Position token based on player index
                    const positions = [
                        {top: '3px', left: '3px'},
                        {top: '3px', right: '3px'},
                        {bottom: '3px', left: '3px'},
                        {bottom: '3px', right: '3px'}
                    ];
                    
                    const pos = positions[playerIndex % positions.length];
                    Object.assign(token.style, pos);
                    
                    cell.appendChild(token);
                    
                    // Highlight current player's cell
                    if (playerIndex === gameState.currentPlayerIndex) {
                        cell.classList.add('active');
                    } else {
                        cell.classList.remove('active');
                    }
                }
            });
        }

        // Generate player cards
        function updatePlayerCards() {
            playersPanel.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                const isActive = index === gameState.currentPlayerIndex;
                const card = document.createElement('div');
                card.className = `player-card ${isActive ? 'active' : ''}`;
                card.innerHTML = `
                    <div class="player-header">
                        <div class="player-color-indicator" style="background: ${player.color}"></div>
                        <div class="player-name">${player.name}</div>
                        ${isActive ? 'üëë' : ''}
                    </div>
                    <div class="player-stats">
                        <div class="stat-item">
                            <span>Position:</span>
                            <span class="stat-value">${player.position}</span>
                        </div>
                        <div class="stat-item">
                            <span>Knowledge:</span>
                            <span class="stat-value">${player.knowledgePoints}</span>
                        </div>
                        <div class="stat-item">
                            <span>Money:</span>
                            <span class="stat-value">${player.money}</span>
                        </div>
                        <div class="stat-item">
                            <span>Properties:</span>
                            <span class="stat-value">${player.propertiesOwned || 0}</span>
                        </div>
                    </div>
                `;
                playersPanel.appendChild(card);
            });
        }

        // Start the game
        function startGame() {
            gameState.players = [];
            const playerCount = parseInt(playerCountSelect.value);
            
            for (let i = 0; i < playerCount; i++) {
                gameState.players.push({
                    name: document.getElementById(`playerName${i}`).value,
                    color: document.getElementById(`playerColor${i}`).value,
                    knowledgePoints: STARTING_KNOWLEDGE,
                    money: STARTING_MONEY,
                    position: 0,
                    turnCount: 0,
                    correctAnswers: 0,
                    propertiesOwned: 0,
                    getOutOfJailFree: false,
                    inJail: false,
                    jailTurns: 0
                });
            }
            
            // Reset properties
            gameState.properties.forEach(prop => {
                prop.owner = null;
                prop.mortgaged = false;
            });
            
            // Shuffle decks
            shuffleArray(gameState.communityChestDeck);
            shuffleArray(gameState.chanceDeck);
            
            gameState.currentPlayerIndex = 0;
            gameState.gameActive = true;
            gameState.diceRolled = false;
            gameState.questionAnswered = false;
            
            playerSetup.style.display = 'none';
            gameContainer.style.display = 'block';
            
            generateBoard();
            updatePlayerCards();
            updateCurrentPlayerDisplay();
            
            addLog(`Reform Monopoly begins! ${playerCount} reformers competing.`);
            enableRollDice();
        }

        // Shuffle array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Update current player display
        function updateCurrentPlayerDisplay() {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            currentPlayerNameEl.textContent = currentPlayer.name;
            currentPlayerNameEl.style.color = currentPlayer.color;
        }

        // Enable/disable dice roll
        function enableRollDice() {
            rollDiceBtn.disabled = false;
            nextTurnBtn.disabled = true;
            nextTurnBtn.style.display = 'none';
            rollDiceBtn.style.display = 'block';
            gameState.diceRolled = false;
            gameState.questionAnswered = false;
        }

        // Roll dice
        async function rollDice() {
            if (!gameState.gameActive || gameState.diceRolled) return;
            
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            
            // Check if player is in jail
            if (currentPlayer.inJail) {
                handleJailTurn(currentPlayer);
                return;
            }
            
            // Disable roll button during animation
            rollDiceBtn.disabled = true;
            rollDiceBtn.textContent = 'Rolling...';
            
            // Add rolling animation to both dice
            dice1.classList.add('rolling');
            dice2.classList.add('rolling');
            
            // Roll animation for 1 second
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Generate dice values
            const dice1Value = Math.floor(Math.random() * 6) + 1;
            const dice2Value = Math.floor(Math.random() * 6) + 1;
            const total = dice1Value + dice2Value;
            
            // Update dice display
            dice1.textContent = getDiceFace(dice1Value);
            dice2.textContent = getDiceFace(dice2Value);
            
            // Remove rolling animation
            dice1.classList.remove('rolling');
            dice2.classList.remove('rolling');
            
            diceResultEl.textContent = `${currentPlayer.name} rolled ${dice1Value} + ${dice2Value} = ${total}!`;
            
            gameState.diceRolled = true;
            
            // Move player
            moveCurrentPlayer(total, dice1Value === dice2Value);
        }

        // Get dice face Unicode character
        function getDiceFace(value) {
            const faces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
            return faces[value - 1];
        }

        // Handle jail turn
        function handleJailTurn(player) {
            player.jailTurns++;
            
            if (player.jailTurns >= 3) {
                player.money -= 50;
                player.inJail = false;
                player.jailTurns = 0;
                addLog(`${player.name} pays 50 KP to get out of Janissary Crisis!`);
                enableRollDice();
            } else {
                const dice1Value = Math.floor(Math.random() * 6) + 1;
                const dice2Value = Math.floor(Math.random() * 6) + 1;
                
                dice1.textContent = getDiceFace(dice1Value);
                dice2.textContent = getDiceFace(dice2Value);
                
                if (dice1Value === dice2Value) {
                    player.inJail = false;
                    player.jailTurns = 0;
                    addLog(`${player.name} rolls doubles and gets out of Janissary Crisis!`);
                    moveCurrentPlayer(dice1Value + dice2Value, true);
                } else {
                    addLog(`${player.name} fails to roll doubles. Still in Janissary Crisis.`);
                    gameState.diceRolled = true;
                    enableNextTurn();
                }
            }
            
            updatePlayerCards();
        }

        // Move current player
        function moveCurrentPlayer(spaces, rolledDoubles = false) {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const oldPosition = currentPlayer.position;
            
            // Calculate new position
            let newPosition = (currentPlayer.position + spaces) % 40;
            currentPlayer.position = newPosition;
            
            // Check if passed GO
            if (newPosition < oldPosition) {
                currentPlayer.money += 200;
                addLog(`${currentPlayer.name} passed GO and collected 200 Knowledge Points!`);
            }
            
            // Update display
            updatePlayerTokens();
            updatePlayerCards();
            
            addLog(`${currentPlayer.name} moves to position ${newPosition}`);
            
            // Land on space
            setTimeout(() => landOnSpace(newPosition, rolledDoubles), 500);
        }

        // Land on a space
        function landOnSpace(position, rolledDoubles) {
            const space = BOARD_SPACES.find(s => s.position === position);
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            
            if (!space) {
                enableNextTurn();
                return;
            }
            
            // Mark current space
            gameState.currentSpace = space;
            
            // Handle different space types
            if (space.type === 'property') {
                handlePropertySpace(space, currentPlayer);
            } else if (space.type === 'corner') {
                handleCornerSpace(space, currentPlayer);
            } else if (space.type === 'chance') {
                drawChanceCard(currentPlayer);
            } else if (space.type === 'community-chest') {
                drawCommunityChestCard(currentPlayer);
            } else if (space.type === 'railroad' || space.type === 'utility') {
                handleRailroadUtilitySpace(space, currentPlayer);
            } else if (space.type === 'tax') {
                handleTaxSpace(space, currentPlayer);
            } else {
                cardTextEl.innerHTML = `
                    <h3>${space.name}</h3>
                    <p>${space.description}</p>
                `;
                
                if (rolledDoubles) {
                    addLog(`${currentPlayer.name} rolled doubles! Gets another turn.`);
                    enableRollDice();
                } else {
                    enableNextTurn();
                }
            }
        }

        // Handle property space
        function handlePropertySpace(space, player) {
            const property = gameState.properties.find(p => p.position === space.position);
            
            if (!property) {
                enableNextTurn();
                return;
            }
            
            if (!property.owner) {
                cardTextEl.innerHTML = `
                    <h3>${space.name}</h3>
                    <p>${space.description}</p>
                    <p><strong>Price:</strong> ${space.price} Knowledge Points</p>
                    <p>Would you like to purchase this property?</p>
                    <div style="margin-top: 20px;">
                        <button class="answer-btn" onclick="buyProperty(${space.position})">Buy Property (${space.price} KP)</button>
                        <button class="answer-btn" onclick="skipProperty()" style="margin-top: 10px;">Skip</button>
                    </div>
                `;
            } else if (property.owner === gameState.currentPlayerIndex) {
                cardTextEl.innerHTML = `
                    <h3>${space.name}</h3>
                    <p>You own this property!</p>
                `;
                enableNextTurn();
            } else {
                const owner = gameState.players[property.owner];
                const rent = space.rent;
                
                player.money -= rent;
                owner.money += rent;
                
                cardTextEl.innerHTML = `
                    <h3>${space.name}</h3>
                    <p>Owned by ${owner.name}</p>
                    <p>You pay ${rent} Knowledge Points in rent!</p>
                `;
                
                addLog(`${player.name} pays ${rent} KP rent to ${owner.name} for ${space.name}`);
                updatePlayerCards();
                enableNextTurn();
            }
        }

        // Buy property
        function buyProperty(position) {
            const player = gameState.players[gameState.currentPlayerIndex];
            const property = gameState.properties.find(p => p.position === position);
            const space = BOARD_SPACES.find(s => s.position === position);
            
            if (!property || !space) return;
            
            if (player.money >= space.price) {
                player.money -= space.price;
                property.owner = gameState.currentPlayerIndex;
                player.propertiesOwned = (player.propertiesOwned || 0) + 1;
                
                const cell = document.getElementById(`cell-${position}`);
                if (cell) {
                    cell.classList.add('property-owned');
                    cell.style.borderLeft = `4px solid ${player.color}`;
                }
                
                addLog(`${player.name} buys ${space.name} for ${space.price} KP!`);
                updatePlayerCards();
                
                showPropertyQuestion(space);
            } else {
                cardTextEl.innerHTML = `
                    <h3>Insufficient Funds!</h3>
                    <p>You need ${space.price} KP but only have ${player.money} KP.</p>
                `;
                setTimeout(enableNextTurn, 2000);
            }
        }

        // Skip property
        function skipProperty() {
            enableNextTurn();
        }

        // Show property question
        function showPropertyQuestion(space) {
            if (!space.category) {
                enableNextTurn();
                return;
            }
            
            gameState.currentCard = getRandomFact(space.category);
            if (!gameState.currentCard) {
                enableNextTurn();
                return;
            }
            
            displayCard(space.category, gameState.currentCard);
            nextTurnBtn.style.display = 'none';
            rollDiceBtn.style.display = 'none';
        }

        // Handle corner space
        function handleCornerSpace(space, player) {
            if (space.position === 0) {
                player.money += 200;
                addLog(`${player.name} lands on GO and collects 200 KP!`);
            } else if (space.position === 10) {
                // Just visiting
            } else if (space.position === 20) {
                const freeParkMoney = 100;
                player.money += freeParkMoney;
                addLog(`${player.name} collects ${freeParkMoney} KP from Free Park!`);
            } else if (space.position === 30) {
                player.position = 10;
                player.inJail = true;
                player.jailTurns = 0;
                addLog(`${player.name} goes to Janissary Crisis!`);
                updatePlayerTokens();
            }
            
            cardTextEl.innerHTML = `
                <h3>${space.name}</h3>
                <p>${space.description}</p>
            `;
            updatePlayerCards();
            enableNextTurn();
        }

        // Draw chance card
        function drawChanceCard(player) {
            if (gameState.chanceDeck.length === 0) {
                gameState.chanceDeck = [...CHANCE_CARDS];
                shuffleArray(gameState.chanceDeck);
            }
            
            const card = gameState.chanceDeck.pop();
            cardTextEl.innerHTML = `
                <h3>Chance</h3>
                <p>${card.text}</p>
            `;
            
            if (card.action === 'collect') {
                player.money += card.amount;
                addLog(`${player.name} collects ${card.amount} KP!`);
            } else if (card.action === 'pay') {
                player.money -= card.amount;
                addLog(`${player.name} pays ${card.amount} KP!`);
            }
            
            updatePlayerCards();
            setTimeout(enableNextTurn, 2000);
        }

        // Draw community chest card
        function drawCommunityChestCard(player) {
            if (gameState.communityChestDeck.length === 0) {
                gameState.communityChestDeck = [...COMMUNITY_CHEST_CARDS];
                shuffleArray(gameState.communityChestDeck);
            }
            
            const card = gameState.communityChestDeck.pop();
            cardTextEl.innerHTML = `
                <h3>Community Reform</h3>
                <p>${card.text}</p>
            `;
            
            if (card.action === 'collect') {
                player.money += card.amount;
                addLog(`${player.name} collects ${card.amount} KP!`);
            } else if (card.action === 'pay') {
                player.money -= card.amount;
                addLog(`${player.name} pays ${card.amount} KP!`);
            }
            
            updatePlayerCards();
            setTimeout(enableNextTurn, 2000);
        }

        // Handle railroad/utility space
        function handleRailroadUtilitySpace(space, player) {
            cardTextEl.innerHTML = `
                <h3>${space.name}</h3>
                <p>${space.description}</p>
            `;
            enableNextTurn();
        }

        // Handle tax space
        function handleTaxSpace(space, player) {
            player.money -= space.amount;
            
            cardTextEl.innerHTML = `
                <h3>${space.name}</h3>
                <p>${space.description}</p>
                <p>You pay ${space.amount} Knowledge Points!</p>
            `;
            
            addLog(`${player.name} pays ${space.amount} KP in taxes!`);
            updatePlayerCards();
            enableNextTurn();
        }

        // Display card based on category
        function displayCard(category, card) {
            answerOptionsEl.style.display = 'none';
            factResultEl.style.display = 'none';
            answerOptionsEl.innerHTML = '';
            
            const categoryNames = {
                'did-you-know': 'Did You Know?',
                'true-false': 'True or False?',
                'what-next': 'What Happened Next?',
                'two-truths': 'Two Truths & a Lie'
            };
            
            currentCategoryEl.textContent = categoryNames[category];
            
            switch(category) {
                case 'did-you-know':
                    cardTextEl.textContent = card.text;
                    answerOptionsEl.innerHTML = `
                        <button class="answer-btn" onclick="answerQuestion()">Learn This (Earn ${card.points} points)</button>
                    `;
                    answerOptionsEl.style.display = 'block';
                    break;
                    
                case 'true-false':
                    cardTextEl.textContent = card.text;
                    answerOptionsEl.innerHTML = `
                        <button class="answer-btn" onclick="answerTrueFalse(true)">True</button>
                        <button class="answer-btn" onclick="answerTrueFalse(false)">False</button>
                    `;
                    answerOptionsEl.style.display = 'block';
                    break;
                    
                case 'what-next':
                    cardTextEl.textContent = card.setup;
                    answerOptionsEl.innerHTML = card.options.map((option, index) => `
                        <button class="answer-btn" onclick="answerWhatNext(${index})">${option}</button>
                    `).join('');
                    answerOptionsEl.style.display = 'block';
                    break;
                    
                case 'two-truths':
                    cardTextEl.innerHTML = `
                        <strong>Which statement is the LIE?</strong><br><br>
                        ${card.statements.map((stmt, idx) => 
                            `${idx + 1}. ${stmt}<br><br>`
                        ).join('')}
                    `;
                    answerOptionsEl.innerHTML = card.statements.map((stmt, index) => `
                        <button class="answer-btn" onclick="answerTwoTruths(${index})">Statement ${index + 1}</button>
                    `).join('');
                    answerOptionsEl.style.display = 'block';
                    break;
            }
            
            setTimeout(() => {
                document.querySelectorAll('.answer-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        document.querySelectorAll('.answer-btn').forEach(b => b.disabled = true);
                    });
                });
            }, 100);
        }

        // Get random fact from category
        function getRandomFact(category) {
            const categoryFacts = facts[category];
            return categoryFacts[Math.floor(Math.random() * categoryFacts.length)];
        }

        // Answer handlers
        function answerQuestion() {
            if (gameState.questionAnswered) return;
            
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const card = gameState.currentCard;
            
            currentPlayer.knowledgePoints += card.points;
            currentPlayer.correctAnswers = (currentPlayer.correctAnswers || 0) + 1;
            
            showResult(true, `Knowledge gained! +${card.points} Knowledge Points`);
            addLog(`${currentPlayer.name} earns ${card.points} KP for correct answer!`);
            
            updatePlayerCards();
            gameState.questionAnswered = true;
            
            setTimeout(enableNextTurn, 1500);
        }

        function answerTrueFalse(userAnswer) {
            if (gameState.questionAnswered) return;
            
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const card = gameState.currentCard;
            const isCorrect = userAnswer === card.answer;
            
            if (isCorrect) {
                currentPlayer.knowledgePoints += card.points;
                currentPlayer.correctAnswers = (currentPlayer.correctAnswers || 0) + 1;
                
                showResult(true, `Correct! ${card.explanation} +${card.points} Knowledge Points`);
                addLog(`${currentPlayer.name} answers True/False correctly!`);
            } else {
                showResult(false, `Incorrect. ${card.explanation}`);
                addLog(`${currentPlayer.name} answers True/False incorrectly.`);
            }
            
            updatePlayerCards();
            gameState.questionAnswered = true;
            
            setTimeout(enableNextTurn, 1500);
        }

        function answerWhatNext(selectedIndex) {
            if (gameState.questionAnswered) return;
            
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const card = gameState.currentCard;
            const isCorrect = selectedIndex === card.correct;
            
            if (isCorrect) {
                currentPlayer.knowledgePoints += card.points;
                currentPlayer.correctAnswers = (currentPlayer.correctAnswers || 0) + 1;
                
                showResult(true, `Correct! ${card.explanation} +${card.points} Knowledge Points`);
                addLog(`${currentPlayer.name} predicts historical sequence correctly!`);
            } else {
                showResult(false, `Incorrect. ${card.explanation}`);
                addLog(`${currentPlayer.name} makes wrong historical prediction.`);
            }
            
            updatePlayerCards();
            gameState.questionAnswered = true;
            
            setTimeout(enableNextTurn, 1500);
        }

        function answerTwoTruths(selectedIndex) {
            if (gameState.questionAnswered) return;
            
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const card = gameState.currentCard;
            const isCorrect = selectedIndex === card.lieIndex;
            
            if (isCorrect) {
                currentPlayer.knowledgePoints += card.points;
                currentPlayer.correctAnswers = (currentPlayer.correctAnswers || 0) + 1;
                
                showResult(true, `Correct detective work! ${card.explanation} +${card.points} Knowledge Points`);
                addLog(`${currentPlayer.name} finds the lie successfully!`);
            } else {
                showResult(false, `Not quite. ${card.explanation}`);
                addLog(`${currentPlayer.name} chooses wrong in Two Truths & a Lie`);
            }
            
            updatePlayerCards();
            gameState.questionAnswered = true;
            
            setTimeout(enableNextTurn, 1500);
        }

        // Show result
        function showResult(isCorrect, message) {
            factResultEl.textContent = message;
            factResultEl.className = 'fact-result ' + (isCorrect ? 'correct' : 'incorrect');
            factResultEl.style.display = 'block';
        }

        // Enable next turn button
        function enableNextTurn() {
            nextTurnBtn.disabled = false;
            nextTurnBtn.style.display = 'block';
            rollDiceBtn.style.display = 'none';
        }

        // Next turn
        function nextTurn() {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            currentPlayer.turnCount++;
            
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            
            nextTurnBtn.style.display = 'none';
            rollDiceBtn.style.display = 'block';
            currentCategoryEl.textContent = 'Ready for Next Turn';
            cardTextEl.textContent = `${gameState.players[gameState.currentPlayerIndex].name}'s turn. Click "Roll Dice" to continue!`;
            answerOptionsEl.style.display = 'none';
            factResultEl.style.display = 'none';
            diceResultEl.textContent = '';
            
            updateCurrentPlayerDisplay();
            updatePlayerCards();
            enableRollDice();
            
            addLog(`${gameState.players[gameState.currentPlayerIndex].name}'s turn to roll!`);
        }

        // Reset game
        function resetGame() {
            winnerBanner.style.display = 'none';
            playerSetup.style.display = 'flex';
            gameContainer.style.display = 'none';
        }

        // Add log entry
        function addLog(message) {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = message;
            logEntriesEl.prepend(logEntry);
            
            const entries = logEntriesEl.querySelectorAll('.log-entry');
            if (entries.length > 8) {
                entries[entries.length - 1].remove();
            }
        }

        // Event Listeners
        playerCountSelect.addEventListener('change', initializePlayerForms);
        startGameBtn.addEventListener('click', startGame);
        rollDiceBtn.addEventListener('click', rollDice);
        nextTurnBtn.addEventListener('click', nextTurn);

        // Initialize
        initializePlayerForms();
    </script>
</body>
</html>
